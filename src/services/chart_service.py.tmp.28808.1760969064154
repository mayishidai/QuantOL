import plotly.graph_objects as go
from plotly.subplots import make_subplots
import streamlit as st
from abc import ABC, abstractmethod
from src.services.theme_manager import ThemeManager
from src.services.interaction_service import InteractionService
import pandas as pd
import numpy as np
import plotly.express as px
from typing import List, Optional, Dict, Set, Any, Union, Type
from pandas import DataFrame
from pathlib import Path
import json
import uuid
import time
import logging
logger = logging.getLogger(__name__)

class LayoutConfig:
    def __init__(self):
        self.type = "vertical"
        self.row_heights = [0.7, 0.3]
        self.spacing = 0.1
        self.grid_columns = 2


class DataConfig:
    def __init__(self):
        self.primary_fields = ["close"]
        self.secondary_fields = ["volume"]
        self.field_aliases = {"close": "æ”¶ç›˜ä»·", "volume": "æˆäº¤é‡"}

    def get_display_name(self, field):
        return self.field_aliases.get(field, field)


class ChartConfig:
    """å¯è§†åŒ–é…ç½®ç®¡ç†"""

    def __init__(self, theme_manager=None):
        from services.theme_manager import ThemeManager
        self.theme_manager = theme_manager or ThemeManager()
        self.theme = self.theme_manager.get_theme()  # è·å–é»˜è®¤ä¸»é¢˜é…ç½®
        self.layout = LayoutConfig()
        self.data = DataConfig()
        self._config_manager = ChartConfigManager()
        
    def load(self):
        """æ˜¾å¼åŠ è½½é…ç½®æ–‡ä»¶"""
        config_data = self._config_manager.load_config()
        
        # ç¡®ä¿é…ç½®æ•°æ®æ˜¯å­—å…¸æ ¼å¼
        if not isinstance(config_data, dict):
            st.error(f"é…ç½®æ•°æ®æ ¼å¼é”™è¯¯: {type(config_data)}")
            config_data = self._config_manager._create_default_dict()
        
        # æ›´æ–°é…ç½®
        theme_config = config_data.get("theme", {})
        layout_config = config_data.get("layout", {})
        data_config = config_data.get("data", {})
        
        # æ›´æ–°ä¸»é¢˜é…ç½®
        if theme_config:
            self.theme = self.theme_manager.get_theme(theme_config.get("preset_name"))
        self.layout.__dict__.update(layout_config)
        self.data.__dict__.update(data_config)

    def save(self):
        """ä¿å­˜å½“å‰é…ç½®"""
        self._config_manager.save_config(self)


class ChartConfigManager:
    CONFIG_PATH = Path("src/support/config/chart_config.json")

    @classmethod
    def load_config(cls) -> dict:
        """åŠ è½½é…ç½®å¹¶è¿”å›å­—å…¸"""
        try:
            if cls.CONFIG_PATH.exists():
                with open(cls.CONFIG_PATH, "r", encoding="utf-8") as f:
                    return json.load(f)
        except Exception as e:
            st.error(f"é…ç½®åŠ è½½å¤±è´¥: {str(e)}")
        
        # è¿”å›é»˜è®¤é…ç½®
        return cls._create_default_dict()

    @classmethod
    def save_config(cls, config: ChartConfig):
        """ä¿å­˜é…ç½®åˆ°æ–‡ä»¶"""
        try:
            cls.CONFIG_PATH.parent.mkdir(parents=True, exist_ok=True)
            save_data = {
                "theme": vars(config.theme),
                "layout": vars(config.layout),
                "data": vars(config.data),
            }
            with open(cls.CONFIG_PATH, "w", encoding="utf-8") as f:
                json.dump(save_data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            st.error(f"é…ç½®ä¿å­˜å¤±è´¥: {str(e)}")

    @classmethod
    def _create_default_dict(cls) -> dict:
        """åˆ›å»ºé»˜è®¤é…ç½®å­—å…¸"""
        from services.theme_manager import ThemeManager
        theme_manager = ThemeManager()
        layout = LayoutConfig()
        data = DataConfig()
        
        return {
            "theme": theme_manager.get_theme(),
            "layout": vars(layout),
            "data": vars(data)
        }

    @classmethod
    def _migrate_old_config(cls, raw_data):
        """å°†æ—§ç‰ˆé…ç½®è¿ç§»åˆ°æ–°ç»“æ„"""
        return {
            "theme": {
                "mode": raw_data.get("current_theme", "dark"),
                "colors": raw_data.get("themes", {}),
            },
            "layout": {
                "type": raw_data.get("layout_type", "vertical"),
                "row_heights": raw_data.get("row_heights", [0.6, 0.4]),
            },
            "data": {
                "primary_fields": raw_data.get("primary_fields", []),
                "secondary_fields": raw_data.get("secondary_fields", []),
            },
        }
    @staticmethod
    def _get_default_config():

        default_config = {
            "main_chart": {
                "type": "Kçº¿å›¾",       # ä¸»å›¾ç±»å‹æ ‡è¯†
                "fields": ["close"],  # æ˜¾ç¤ºå­—æ®µ
                "data_source": "kline_data",  # æ•°æ®æºæ ‡è¯†
                "style": {            # æ ·å¼é…ç½®ï¼ˆå‚è€ƒç½‘é¡µ4ï¼‰
                    "line_width": 1.5,
                    "color": "#2c7be5"
                }
            },
            "sub_chart": {
                "show": True,         # æ˜¯å¦æ˜¾ç¤ºå‰¯å›¾
                "type": "æŸ±çŠ¶å›¾",      # å‰¯å›¾ç±»å‹æ ‡è¯†  
                "fields": ["volume"], # æ˜¾ç¤ºå­—æ®µ
                "data_source": "trade_records", # æ•°æ®æºæ ‡è¯†
                "yaxis_name": "æˆäº¤é‡", # Yè½´æ ‡ç­¾
                "style": {
                    "type": "bar",    # å›¾å½¢ç±»å‹ï¼ˆbar/lineï¼‰
                    "opacity": 0.6
                }
            },
            "version": "1.0"
        }
        return default_config
                    


class ChartBase(ABC):
    """å›¾è¡¨åŸºç±»"""
    figure: go.Figure
    logger: logging.Logger = logging.getLogger(__name__)
    default_line_width: float = 1.0
    main_color: str
    north_color: str
    default_up_color: str
    default_down_color: str
    
    def __init__(self, config: ChartConfig):
        self.config = config
        self.figure = go.Figure()
        self.main_color = "#4E79A7"  # é»˜è®¤ä¸»è‰²
        self.north_color = "#59A14F"  # é»˜è®¤åŒ—å‘èµ„é‡‘è‰²
        self.default_up_color = "#25A776"  # é»˜è®¤ä¸Šæ¶¨è‰²
        self.default_down_color = "#EF4444"  # é»˜è®¤ä¸‹è·Œè‰²

    @abstractmethod
    def render(self, data: pd.DataFrame, scope: str) -> go.Figure:
        """æ¸²æŸ“å›¾è¡¨å¹¶è¿”å›Figureå¯¹è±¡
        Args:
            data: å›¾è¡¨æ•°æ®
            scope: æ—¶é—´ç»´åº¦ (second/minute/hour/day/week/month/year)
        """
        pass

class Indicator(ABC):
    """æŒ‡æ ‡åŸºç±»"""
    @abstractmethod
    def apply(self, data: pd.DataFrame) -> List[Union[go.Scatter, go.Bar]]:
        """åº”ç”¨æŒ‡æ ‡å¹¶è¿”å›traceåˆ—è¡¨"""
        pass

# å…ˆå®šä¹‰æ‰€æœ‰å…·ä½“æŒ‡æ ‡ç±»
class MAIndicator(Indicator):
    """å‡çº¿æŒ‡æ ‡"""
    def __init__(self, periods: List[int] = [5, 10, 20]):
        self.periods = periods
    
    def apply(self, data: pd.DataFrame) -> List[go.Scatter]:
        traces = []
        for period in self.periods:
            ma = data["close"].rolling(period).mean()
            traces.append(go.Scatter(
                x=data.index,
                y=ma,
                name=f"MA{period}",
                line=dict(width=1),
                opacity=0.7
            ))
        return traces

class MACDIndicator(Indicator):
    """MACDæŒ‡æ ‡"""
    def __init__(self, fast=12, slow=26, signal=9):
        self.fast = fast
        self.slow = slow 
        self.signal = signal
    
    def apply(self, data: pd.DataFrame) -> List[Union[go.Scatter, go.Bar]]:
        exp1 = data["close"].ewm(span=self.fast, adjust=False).mean()
        exp2 = data["close"].ewm(span=self.slow, adjust=False).mean()
        macd = exp1 - exp2
        signal = macd.ewm(span=self.signal, adjust=False).mean()
        histogram = macd - signal
        
        return [
            go.Scatter(x=data.index, y=macd, name="MACD", line=dict(color="blue")),
            go.Scatter(x=data.index, y=signal, name="Signal", line=dict(color="orange")),
            go.Bar(x=data.index, y=histogram, name="Histogram", 
                  marker_color=np.where(histogram >= 0, "green", "red"))
        ]

class RSIIndicator(Indicator):
    """RSIæŒ‡æ ‡"""
    def __init__(self, window=14):
        self.window = window
    
    def apply(self, data: pd.DataFrame) -> List[go.Scatter]:
        delta: pd.Series = data["close"].diff()
        gain: pd.Series = (delta.where(delta > 0, 0)).rolling(self.window).mean()
        loss: pd.Series = (-delta.where(delta < 0, 0)).rolling(self.window).mean()
        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))
        
        return [
            go.Scatter(x=data.index, y=rsi, name=f"RSI{self.window}", line=dict(color="purple")),
            go.Scatter(x=data.index, y=[30]*len(data), name="è¶…å–çº¿", line=dict(color="red", dash="dash")),
            go.Scatter(x=data.index, y=[70]*len(data), name="è¶…ä¹°çº¿", line=dict(color="red", dash="dash"))
        ]


class IndicatorFactory:
    """æŒ‡æ ‡å·¥å‚ï¼Œç»Ÿä¸€ç®¡ç†æŒ‡æ ‡åˆ›å»º"""
    _registry = {}  # ç±»å‹æ³¨å†Œè¡¨: {"name": IndicatorClass}

    @classmethod
    def register(cls, name: str, indicator_class: Type[Indicator]):
        """æ³¨å†ŒæŒ‡æ ‡ç±»å‹"""
        if not issubclass(indicator_class, Indicator):
            raise TypeError(f"{indicator_class.__name__} must inherit from Indicator")
        cls._registry[name] = indicator_class

    @classmethod
    def create(cls, name: str, **params) -> Indicator:
        """åˆ›å»ºæŒ‡æ ‡å®ä¾‹"""
        if name not in cls._registry:
            raise ValueError(f"Unknown indicator: {name}. Available: {list(cls._registry.keys())}")
        return cls._registry[name](**params)

    @classmethod
    def get_available_indicators(cls) -> List[str]:
        """è·å–å·²æ³¨å†Œçš„æŒ‡æ ‡ç±»å‹åˆ—è¡¨"""
        return list(cls._registry.keys())

# æ³¨å†Œå†…ç½®æŒ‡æ ‡ç±»å‹
IndicatorFactory.register("ma", MAIndicator)
IndicatorFactory.register("macd", MACDIndicator)
IndicatorFactory.register("rsi", RSIIndicator)
# ç§»é™¤é‡å¤çš„æŒ‡æ ‡ç±»å®šä¹‰

class IndicatorDecorator(ChartBase):
    """æŒ‡æ ‡è£…é¥°å™¨ï¼Œæ”¯æŒå·¥å‚æ¨¡å¼åˆ›å»ºæŒ‡æ ‡"""
    def __init__(self, chart: ChartBase, indicators: Union[List[Indicator], List[dict], str]):
        self._chart = chart   # å›¾è¡¨
        self._indicators = []  # æŒ‡æ ‡
        
        # æ”¯æŒå¤šç§è¾“å…¥æ ¼å¼ï¼š
        # 1. å­—å…¸é…ç½®åˆ—è¡¨ - é€šè¿‡å·¥å‚åˆ›å»º
        # 2. Indicatorå®ä¾‹åˆ—è¡¨ - ç›´æ¥ä½¿ç”¨
        # 3. å­—ç¬¦ä¸²åˆ—è¡¨ - ä½¿ç”¨é»˜è®¤å‚æ•°åˆ›å»º
        for item in indicators if isinstance(indicators, list) else [indicators]:
            if isinstance(item, dict):
                self._indicators.append(IndicatorFactory.create(**item))
            elif isinstance(item, Indicator):
                self._indicators.append(item)
            elif isinstance(item, str):
                self._indicators.append(IndicatorFactory.create(item))
            else:
                raise TypeError(f"Invalid indicator type: {type(item)}")
    
    def render(self, data: pd.DataFrame, scope: str) -> go.Figure:
        """æ¸²æŸ“å›¾è¡¨å¹¶æ·»åŠ æŒ‡æ ‡"""
        fig = self._chart.render(data, scope)
        
        # åº”ç”¨ä¸»é¢˜é…ç½®
        theme = self._chart.config.theme if hasattr(self._chart, 'config') else {}
        
        for indicator in self._indicators:
            for trace in indicator.apply(data):
                # åº”ç”¨ä¸»é¢˜é¢œè‰²
                if hasattr(trace, 'line') and trace.line and 'color' not in trace.line:
                    trace.line.color = theme.get("primary_color", "#2c7be5")
                fig.add_trace(trace)
        
        return fig


# ç¡®ä¿å›¾è¡¨ç±»å®šä¹‰åœ¨å·¥å‚ç±»ä¹‹å‰
class CapitalFlowChart(ChartBase):
    """èµ„é‡‘æµå›¾è¡¨å®ç°"""
    main_color: str
    north_color: str
    
    def __init__(self, config: ChartConfig):
        super().__init__(config)
        self.main_color = "#4E79A7"
        self.north_color = "#59A14F"

    def render(self, data: pd.DataFrame, scope: str = "day") -> go.Figure:
        """èµ„é‡‘æµå›¾è¡¨æ¸²æŸ“
        Args:
            data: èµ„é‡‘æµæ•°æ®
            scope: æ—¶é—´ç»´åº¦ (day/week/month/year/minute)
        """
        from plotly.subplots import make_subplots
        self.figure = make_subplots(specs=[[{"secondary_y": True}]])
        self.figure.add_trace(
            go.Bar(
                x=data["date"],
                y=data["main_net"],
                name="ä¸»åŠ›å‡€æµå…¥",
                marker_color=self.main_color,
                opacity=0.7,
            ),
            secondary_y=False,
        )
        self.figure.add_trace(
            go.Scatter(
                x=data["date"],
                y=data["north_net"].cumsum(),
                name="åŒ—å‘ç´¯è®¡",
                line=dict(color=self.north_color, width=2),
                secondary_y=True,
            )
        )
        theme = self.config.theme
        self.figure.update_layout(
            plot_bgcolor=theme["background"],
            paper_bgcolor=theme["background"],
            barmode="relative",
            title="èµ„é‡‘æµå‘åˆ†æ",
            title_font=dict(size=14, family=theme.get("font", "Arial")),
            legend=dict(font=dict(size=10, family=theme.get("font", "Arial"))),
        )
        return self.figure


class CandlestickChart(ChartBase):
    """Kçº¿å›¾è¡¨å®ç°"""
    def __init__(self, config: ChartConfig):
        super().__init__(config)

    def render(self, data: pd.DataFrame, scope: str) -> go.Figure:
        """Kçº¿å›¾è¡¨æ¸²æŸ“
        Args:
            data: Kçº¿æ•°æ®
            scope: æ—¶é—´ç»´åº¦ (second/minute/hour/day/week/month/year)
        """
        # ç»˜åˆ¶Kçº¿
        self.figure.add_trace(
            go.Candlestick(
                x=data.index,
                open=data["open"],
                high=data["high"],
                low=data["low"],
                close=data["close"],
                name="Kçº¿",  # è®¾ç½®traceåç§°
                increasing_line_color="#25A776",
                decreasing_line_color="#EF4444",
            )
        )
        

        # æ˜¾å¼ç¦ç”¨ç¼©ç•¥å›¾
        self.figure.update_layout(xaxis_rangeslider_visible=False)
        
        # åº”ç”¨ä¸»é¢˜é…ç½®
        theme = self.config.theme
        layout = self.config.layout

        self.figure.update_layout(
            plot_bgcolor=theme["background"],
            paper_bgcolor=theme["background"],
            xaxis=dict(
                title="æ—¶é—´",
                tickvals=data.index[::100],
                ticktext=data["date" if scope in ("day", "week", "month", "year") else "time"][::100],
                tickangle=45,
                gridcolor=theme["grid"],
                title_font=dict(size=12, family=theme.get("font", "Arial")),
            ),
            yaxis=dict(
                gridcolor=theme["grid"],
                title_font=dict(size=12, family=theme.get("font", "Arial")),
            ),
            title_font=dict(size=14, family=theme.get("font", "Arial")),
            legend=dict(font=dict(size=10, family=theme.get("font", "Arial"))),
            margin=dict(t=30, b=30)  # æ·»åŠ ä¸Šä¸‹è¾¹è·
        )
        return self.figure


class VolumeChart(ChartBase):
    """æˆäº¤é‡å›¾è¡¨å®ç°"""
    default_up_color: str
    default_down_color: str
    
    def __init__(self, config: ChartConfig):
        super().__init__(config)
        self.default_up_color = "#25A776"
        self.default_down_color = "#EF4444"

    def render(self, data: pd.DataFrame, scope: str = "day") -> go.Figure:
        """æˆäº¤é‡å›¾è¡¨æ¸²æŸ“
        Args:
            data: æˆäº¤é‡æ•°æ®
            scope: æ—¶é—´ç»´åº¦ (day/week/month/year/minute)
        """
        # è®¡ç®—æ¶¨è·Œé¢œè‰²
        colors = np.where(
            data["close"] >= data["open"],
            self.default_up_color,
            self.default_down_color,
        )

        # ç»˜åˆ¶æˆäº¤é‡
        self.figure.add_trace(
            go.Bar(x=data.index, y=data["volume"], marker_color=colors, name="æˆäº¤é‡")
        )

        # åº”ç”¨ä¸»é¢˜é…ç½®
        theme = self.config.theme
        layout = self.config.layout

        self.figure.update_layout(
            title="æˆäº¤é‡",
            plot_bgcolor=theme["background"],
            paper_bgcolor=theme["background"],
            xaxis=dict(
                
                title="æ—¶é—´",
                tickvals=data.index[::100],
                ticktext=data["date" if scope in ("day", "week", "month", "year") else "time"][::100],
                tickangle=45,
                gridcolor=theme["grid"],
                title_font=dict(size=12, family=theme.get("font", "Arial")),
            ),
            yaxis=dict(
                gridcolor=theme["grid"],
                title_font=dict(size=12, family=theme.get("font", "Arial")),
            ),
            title_font=dict(size=14, family=theme.get("font", "Arial")),
            legend=dict(font=dict(size=10, family=theme.get("font", "Arial"))),
        )
        return self.figure


class ChartFactory:
    """å›¾è¡¨å·¥å‚ç±»ï¼Œæ”¯æŒåŠ¨æ€æ³¨å†Œå’Œåˆ›å»ºå›¾è¡¨å®ä¾‹"""
    
    _chart_types = {}  # å­˜å‚¨æ³¨å†Œçš„å›¾è¡¨ç±»å‹
    
    @classmethod
    def register_chart(cls, chart_type: str, chart_class):
        """æ³¨å†Œæ–°çš„å›¾è¡¨ç±»å‹
        
        Args:
            chart_type: å›¾è¡¨ç±»å‹æ ‡è¯†å­—ç¬¦ä¸²
            chart_class: å›¾è¡¨å®ç°ç±»(å¿…é¡»ç»§æ‰¿è‡ªChartBase)
        """
        if not issubclass(chart_class, ChartBase):
            raise TypeError(f"{chart_class.__name__} å¿…é¡»ç»§æ‰¿è‡ª ChartBase")
        cls._chart_types[chart_type] = chart_class
    
    @classmethod
    def create_chart(cls, chart_type: str, config: ChartConfig) -> ChartBase:
        """åˆ›å»ºå›¾è¡¨å®ä¾‹
        
        Args:
            chart_type: å›¾è¡¨ç±»å‹æ ‡è¯†å­—ç¬¦ä¸²
            config: å›¾è¡¨é…ç½®å¯¹è±¡
            
        Returns:
            å›¾è¡¨å®ä¾‹
            
        Raises:
            ValueError: å¦‚æœå›¾è¡¨ç±»å‹æœªæ³¨å†Œ
        """
        if chart_type not in cls._chart_types:
            raise ValueError(f"æœªçŸ¥çš„å›¾è¡¨ç±»å‹: {chart_type}. å¯ç”¨ç±»å‹: {list(cls._chart_types.keys())}")
        return cls._chart_types[chart_type](config)
    
    @classmethod
    def get_registered_charts(cls) -> list:
        """è·å–å·²æ³¨å†Œçš„å›¾è¡¨ç±»å‹åˆ—è¡¨"""
        return list(cls._chart_types.keys())


# æ³¨å†Œå†…ç½®å›¾è¡¨ç±»å‹
ChartFactory.register_chart("capital_flow", CapitalFlowChart)
ChartFactory.register_chart("candlestick", CandlestickChart)
ChartFactory.register_chart("volume", VolumeChart)






class CombinedChartConfig(ChartConfig):
    def __init__(self):
        super().__init__()
        self.layout_type = st.sidebar.selectbox(
            "å¸ƒå±€æ–¹å¼", options=["å‚ç›´å †å ", "ç½‘æ ¼æ’åˆ—"], index=0
        )
        self.row_heights = [0.6, 0.4]  # é»˜è®¤Kçº¿+æˆäº¤é‡é«˜åº¦æ¯”ä¾‹
        self.vertical_spacing = 0.05


class DataBundle:
    """æ•°æ®å®¹å™¨ï¼Œç”¨äºå­˜å‚¨å¤šç§ç±»å‹çš„æ•°æ®"""
    kline_data: Optional[DataFrame]
    trade_records: Optional[DataFrame]
    capital_flow: Optional[DataFrame]

    def __init__(
        self,
        raw_data: Optional[DataFrame] = None,
        transaction_data: Optional[DataFrame] = None,
        capital_flow_data: Optional[DataFrame] = None,
    ):
        self.kline_data = raw_data
        self.trade_records = transaction_data
        self.capital_flow = capital_flow_data
        self.kline_data = raw_data  # Kçº¿æ•°æ®
        self.trade_records = transaction_data  # äº¤æ˜“è®°å½•
        self.capital_flow = capital_flow_data  # æ–°å¢èµ„é‡‘æµæ•°æ®å­—æ®µ

    def get_all_columns(self) -> List[str]:
        """è·å–æ‰€æœ‰åˆ—å"""
        columns = set()
        # éå†æ‰€æœ‰æ•°æ®å®¹å™¨å­—æ®µ
        for attr in ["kline_data", "trade_records", "capital_flow"]:
            df = getattr(self, attr)
            if df is not None and isinstance(df, DataFrame):
                columns.update(df.columns.tolist())
        return list(columns)  # è½¬æ¢ä¸ºåˆ—è¡¨è¿”å›


class ChartService:
    """å›¾è¡¨æœåŠ¡ï¼Œæ”¯æŒå¤šç§æ•°æ®æºçš„å›¾è¡¨ç»˜åˆ¶"""
    logger: logging.Logger = logging.getLogger(__name__)
    default_line_width: float = 1.0
    data_bundle: DataBundle
    figure: go.Figure
    _selected_primary_fields: List[str]
    _selected_secondary_fields: List[str]
    _chart_types: Dict[str, str]

    def __init__(self, data_bundle: DataBundle):
        self.data_bundle = data_bundle
        self._interaction_service = None
        self.figure = go.Figure()
        self._selected_primary_fields = []
        self._selected_secondary_fields = []
        self._chart_types = {"primary": "Kçº¿å›¾", "secondary": "æŸ±å½¢å›¾"}
        self.index = None  # åˆå§‹åŒ–indexå±æ€§
        self._config = None  # åˆå§‹åŒ–é…ç½®å±æ€§

    def _get_interaction_service(self):
        """æƒ°æ€§è·å–InteractionServiceå®ä¾‹"""
        if self._interaction_service is None:
            self._interaction_service = InteractionService()
        return self._interaction_service

    @staticmethod
    def get_chart_service(data_bundle: DataBundle, _strategy_id: Optional[str] = None) -> 'ChartService':
        """åŸºäºç­–ç•¥IDçš„ç¼“å­˜å®ä¾‹å·¥å‚
        
        Args:
            data_bundle: å¿…éœ€çš„æ•°æ®å®¹å™¨å¯¹è±¡
            _strategy_id: å¯é€‰ç­–ç•¥IDï¼Œç”¨äºç¼“å­˜éš”ç¦»
            
        Returns:
            ChartServiceå®ä¾‹
            
        Raises:
            ValueError: å¦‚æœdata_bundleä¸ºNone
        """
        if data_bundle is None:
            raise ValueError("data_bundleå‚æ•°ä¸èƒ½ä¸ºNone")
        return ChartService(data_bundle)

    def _handle_config_change(self, *args):
        """å¤„ç†é…ç½®å˜æ›´çš„å›è°ƒå‡½æ•°"""
        if len(args) == 0:
            return
            
        # è§£æå‚æ•° - Streamlitä¼šä¼ é€’3ä¸ªå‚æ•°: widget_key, value, field_type
        if len(args) >= 3:
            _, _, field_type = args
        elif len(args) >= 2:
            _, field_type = args
        else:
            field_type = args[0]

        # é˜²æŠ–æœºåˆ¶ï¼šå¦‚æœè·ç¦»ä¸Šæ¬¡å˜æ›´æ—¶é—´å°äº300msåˆ™å¿½ç•¥
        current_time = time.time()
        if current_time - st.session_state.get("last_change", 0) < 0.3:
            return
        st.session_state["last_change"] = current_time

        # è·å–é…ç½®key
        config_key = f"chart_config_{st.session_state.chart_instance_id}"

        # è·å–æ–°å€¼
        new_value = st.session_state[f"{st.session_state.strategy_id}_{field_type}"]

        # æ›´æ–°é…ç½®
        if field_type in ["main_type", "main_fields"]:
            st.session_state[config_key]["main_chart"].update(
                {field_type.split("_")[1]: new_value}
            )
        elif field_type in ["sub_type", "sub_fields", "show_sub"]:
            key_map = {
                "sub_type": "type",
                "sub_fields": "fields", 
                "show_sub": "show"
            }
            st.session_state[config_key]["sub_chart"].update(
                {key_map[field_type]: new_value}
            )

        # è®¾ç½®é‡ç»˜æ ‡å¿—
        st.session_state["need_redraw"] = True

    def _refresh_chart(self, config: dict):
        """æ ¹æ®é…ç½®åˆ·æ–°å›¾è¡¨"""
        # æ›´æ–°ä¸»å›¾ç±»å‹
        self._chart_types["primary"] = config["main_chart"]["type"]
        # æ›´æ–°å‰¯å›¾ç±»å‹
        self._chart_types["secondary"] = config["sub_chart"]["type"]
        # æ›´æ–°ä¸»å›¾å­—æ®µ
        self._selected_primary_fields = config["main_chart"]["fields"]
        # æ›´æ–°å‰¯å›¾å­—æ®µ
        self._selected_secondary_fields = config["sub_chart"]["fields"]

    def render_chart_controls(self) -> go.Figure:
        """æ¸²æŸ“ä½œå›¾é…ç½®"""
        # åˆå§‹åŒ–é…ç½®
        if not hasattr(st.session_state, 'chart_instance_id'):
            st.session_state.chart_instance_id = str(uuid.uuid4())
            
        # ç”Ÿæˆé…ç½®key
        config_key = f"chart_config_{st.session_state.chart_instance_id}"

        # åˆå§‹åŒ–é…ç½®
        if config_key not in st.session_state:
            st.session_state[config_key] = ChartConfigManager._get_default_config()
            
        # ç¡®ä¿ç­–ç•¥IDå­˜åœ¨
        if not hasattr(st.session_state, 'strategy_id'):
            st.session_state.strategy_id = "default_strategy"


        # æ–°é…ç½®new_configåˆå§‹åŒ–
        if "new_config" not in st.session_state:
            st.session_state.new_config = ChartConfigManager._get_default_config()  # åˆå§‹åŒ–é»˜è®¤é…ç½®
        if "config_key" not in st.session_state:
            st.session_state.config_key = ChartConfigManager._get_default_config()  # åˆå§‹åŒ–é»˜è®¤é…ç½®
             

        # # ç‰‡æ®µçº§çŠ¶æ€åˆå§‹åŒ–
        # fragment_id = f"chart_fragment_{uuid.uuid4().hex[:8]}"
        # fragment_state = {
        #     "main_chart": {"type": "Kçº¿å›¾", "fields": ["close"]},
        #     "sub_chart": {"show": True, "type": "æŸ±çŠ¶å›¾", "fields": ["volume"]},
        #     "expander_expanded": True,
        #     "version": 1,
        # }




        # æ¸²æŸ“ä¸»å›¾é…ç½®
        @st.fragment
        def render_main_chart_config():
            """æ¸²æŸ“ä¸»å›¾é…ç½®é€‰é¡¹"""
            col1, col2 = st.columns(2)
            with col1:
                new_type = st.selectbox(
                    "ä¸»å›¾ç±»å‹",
                    options=["æŠ˜çº¿å›¾", "Kçº¿å›¾", "é¢ç§¯å›¾"],
                    key=f"{st.session_state.strategy_id}_main_type",
                    index=["æŠ˜çº¿å›¾", "Kçº¿å›¾", "é¢ç§¯å›¾"].index(
                        st.session_state.config_key["main_chart"]["type"]
                    ),
                    on_change=self._handle_config_change,
                    args=(config_key, "main_type"),
                )
            with col2:
                available_fields = self.data_bundle.get_all_columns()
                if new_type == "Kçº¿å›¾":
                    required_fields = {"open", "low", "high", "close"}
                    current_fields = set(st.session_state.config_key["main_chart"]["fields"])

                    # å¼ºåˆ¶åˆå¹¶å¿…é€‰å­—æ®µï¼ˆä¸å…è®¸ç”¨æˆ·åˆ é™¤ï¼‰
                    final_fields = list(current_fields.union(required_fields))

                    # æ¸²æŸ“å¤šé€‰æ¡†ï¼ˆè‡ªåŠ¨é€‰ä¸­å¿…é€‰å­—æ®µï¼‰
                    new_fields = st.multiselect(
                        "ä¸»å›¾å­—æ®µ",
                        options=available_fields,
                        default=final_fields,
                        key=f"{st.session_state.strategy_id}_main_fields",
                        on_change=self._handle_config_change,
                        args=(st.session_state.config_key, "main_fields"),
                    )

                    # å…³é”®ï¼šå¼ºåˆ¶å›å†™å¿…é€‰å­—æ®µï¼Œé˜²æ­¢ç”¨æˆ·åˆ é™¤
                    st.session_state.config_key["main_chart"]["fields"] = list(set(new_fields).union(required_fields))
                else:
                    new_fields = st.multiselect(
                        "ä¸»å›¾å­—æ®µ",
                        options=available_fields,
                        default=st.session_state.config_key["main_chart"]["fields"],
                        key=f"{st.session_state.strategy_id}_main_fields",
                        on_change=self._handle_config_change,
                        args=(st.session_state.config_key, "main_fields"),
                    )
            
            st.session_state.new_config["main_chart"]["type"] = new_type
            st.session_state.new_config["main_chart"]["fields"] = new_fields

        # æ¸²æŸ“å‰¯å›¾é…ç½®
        @st.fragment
        def render_sub_chart_config():
            """æ¸²æŸ“å‰¯å›¾é…ç½®é€‰é¡¹"""
            # åˆå§‹åŒ–é»˜è®¤å€¼
            new_sub_type = "æŸ±çŠ¶å›¾"
            new_sub_fields = ["volume"]
            
            show_sub = st.checkbox(
                "æ˜¾ç¤ºå‰¯å›¾",
                value=st.session_state.config_key["sub_chart"]["show"],
                key=f"{st.session_state.strategy_id}_show_sub",
                on_change=self._handle_config_change,
                args=(st.session_state.config_key, "show_sub"),
            )

            if st.session_state.config_key["sub_chart"]["show"]:
                col3, col4 = st.columns(2)
                with col3:
                    new_sub_type = st.selectbox(
                        "å‰¯å›¾ç±»å‹",
                        options=["æŸ±çŠ¶å›¾", "æŠ˜çº¿å›¾", "MACD"],
                        key=f"{st.session_state.strategy_id}_sub_type",
                        index=["æŸ±çŠ¶å›¾", "æŠ˜çº¿å›¾", "MACD"].index(
                            st.session_state.config_key["sub_chart"]["type"]
                        ),
                        on_change=self._handle_config_change,
                        args=(st.session_state.config_key, "sub_type"),
                    )
                with col4:
                    available_fields = self.data_bundle.get_all_columns()
                    new_sub_fields = st.multiselect(
                        "å‰¯å›¾å­—æ®µ",
                        options=available_fields,
                        default=st.session_state.config_key["sub_chart"]["fields"],
                        key=f"{st.session_state.strategy_id}_sub_fields",
                        on_change=self._handle_config_change,
                        args=(st.session_state.config_key, "sub_fields"),
                    )
            st.session_state.new_config["sub_chart"]["type"] = new_sub_type
            st.session_state.new_config["sub_chart"]["fields"] = new_sub_fields

        # æ¸²æŸ“ä¿å­˜å’Œé‡ç½®æŒ‰é’®ï¼Œä½œå›¾
        @st.fragment
        def render_save_and_reset_buttons():
            """æ¸²æŸ“ä¿å­˜å’Œé‡ç½®æŒ‰é’®"""
            col5, col6 = st.columns(2)
            with col5:
                if st.button("ğŸ’¾ ä¿å­˜é…ç½®", key=f"save_{config_key}"):

                    # ç›´æ¥ä½¿ç”¨session_stateçš„æœ€æ–°å€¼
                    st.session_state[config_key].update(st.session_state.new_config)  # æ›´æ–°ä¿å­˜çš„é…ç½®
                    self.logger.debug(f"ä½œå›¾é…ç½®å·²ä¿å­˜ï¼š{st.session_state.config_key}")
                    st.session_state["need_redraw"] = True

                    # ä½¿ç”¨æ›´è½»é‡çš„é€šçŸ¥æ–¹å¼
                    st.toast("âœ… é…ç½®å·²ä¿å­˜", icon="ğŸ’¾")
                    

            with col6:
                if st.button("ğŸ”„ é‡ç½®", key=f"reset_{config_key}"):
                    st.session_state[config_key].update(ChartConfigManager._get_default_config())
                    
                    st.toast("âš¡ é…ç½®å·²é‡ç½®", icon="ğŸ”„")
                    self.logger.debug(f"ä½œå›¾é…ç½®å·²é‡ç½®ï¼š{st.session_state[config_key]}")
                    st.session_state.need_redraw = True

        # æ‰§è¡Œæ¸²æŸ“
        with st.expander("ğŸ“Š å›¾è¡¨é…ç½®", expanded=True):  # ç¡®ä¿é»˜è®¤å±•å¼€
            render_main_chart_config()
            render_sub_chart_config()
            render_save_and_reset_buttons()

        with st.expander("ä¼šè¯çŠ¶æ€ç›‘æ§"):
            st.write(st.session_state)


        # ç‰ˆæœ¬é©±åŠ¨æ›´æ–°
        if st.session_state.get("config_version") != st.session_state.config_key["version"]:
            self._refresh_chart(st.session_state.config_key)
            st.session_state.config_version = st.session_state.config_key["version"]

        return self.figure

    @st.fragment
    def render_chart_button(self, config: dict):
        """æ¸²æŸ“ä½œå›¾æŒ‰é’®"""

           
        
        self.logger.debug(set(config["main_chart"]["fields"]))
        
        if st.button("æ˜¾ç¤ºå›æµ‹æ›²çº¿", key="draw_backtest"):
            ma_traces = self.render_ma()
            REQUIRED_KLINE_FIELDS = {"open", "low", "high", "close"}
            if (
                config["main_chart"]["type"] == "Kçº¿å›¾"
                and not REQUIRED_KLINE_FIELDS.issubset(set(config["main_chart"]["fields"]))
            ):
                # æ˜¾ç¤ºé”™è¯¯æç¤ºï¼ˆæ”¯æŒ 3 ç§æ–¹å¼ï¼‰
                st.toast(":red[é”™è¯¯] Kçº¿å›¾å¿…é¡»åŒ…å« open/low/high/close å­—æ®µ", icon="ğŸ”¥")  # è½»é‡æç¤º
            else:
                # ç¡®ä¿é…ç½®å·²å›ºåŒ–åˆ°ä¼šè¯çŠ¶æ€
                if "config_key" not in st.session_state:
                    st.session_state.config_key = ChartConfigManager._get_default_config()  # åˆå§‹åŒ–é»˜è®¤é…ç½®
                
                # ç”Ÿæˆå›¾è¡¨
                fig = self.create_combined_chart(config)
                for trace in ma_traces:
                  fig.add_trace(trace)
                st.write(fig)

    def create_interactive_chart(self) -> go.Figure:
        """ç”Ÿæˆäº¤äº’å¼é…ç½®çš„å›¾è¡¨"""
        if not hasattr(self, 'figure'):
            self.figure = go.Figure()
        # å‚æ•°æœ‰æ•ˆæ€§æ£€æŸ¥
        if not self._selected_primary_fields:
            raise ValueError("è‡³å°‘éœ€è¦é€‰æ‹©ä¸€ä¸ªä¸»å›¾å­—æ®µ")

        # åˆ›å»ºåŸºç¡€å›¾è¡¨
        fig = self.create_combined_chart(
            primary_cols=self._selected_primary_fields,
            secondary_cols=(
                self._selected_secondary_fields
                if self._selected_secondary_fields
                else None
            ),
        )

        return fig

    def create_kline(self, scope: str = "day", auto_listen: bool = False) -> go.Figure:
        """åˆ›å»ºKçº¿å›¾(é€šè¿‡å·¥å‚æ¨¡å¼)
        Args:
            scope: æ—¶é—´ç»´åº¦ (day/week/month/year/minute)
            auto_listen: æ˜¯å¦è‡ªåŠ¨æ³¨å†Œäº¤äº’äº‹ä»¶ç›‘å¬ï¼Œé»˜è®¤ä¸ºFalse
        """
        # logging
        logger.debug(f"å¼€å§‹åˆ›å»ºKçº¿å›¾ï¼Œæ•°æ®å½¢çŠ¶: {self.data_bundle.kline_data.shape if self.data_bundle.kline_data is not None else 'None'}",
                   extra={'connection_id': str(id(self))})
        if self.data_bundle.kline_data is None:
            logger.error("åˆ›å»ºKçº¿å›¾å¤±è´¥: ç¼ºå°‘Kçº¿æ•°æ®",
                       extra={'connection_id': str(id(self))})
            raise ValueError("ç¼ºå°‘Kçº¿æ•°æ®")

        # é€šè¿‡å·¥å‚åˆ›å»ºå›¾è¡¨å®ä¾‹
        config = ChartConfig()
        kline = ChartFactory.create_chart("candlestick", config)
        
        # æ·»åŠ æŒ‡æ ‡è£…é¥°
        decorated_chart = IndicatorDecorator(
            kline,
            indicators=[MAIndicator([5, 10, 20])]
        )
        
        fig = decorated_chart.render(self.data_bundle.kline_data, scope)
        self.figure = fig
        
        # åªæœ‰auto_listenä¸ºTrueæ—¶æ‰æ³¨å†Œäº‹ä»¶ç›‘å¬
        if auto_listen:
            self._get_interaction_service().subscribe(
                lambda x_range: fig.update_xaxes(range=x_range))
            
        logger.debug("Kçº¿å›¾åˆ›å»ºå®Œæˆ",
                    extra={'connection_id': str(id(self))})
        return fig

    def create_volume_chart(self, auto_listen: bool = False) -> go.Figure:
        """åˆ›å»ºæˆäº¤é‡å›¾(é€šè¿‡å·¥å‚æ¨¡å¼)
        Args:
            auto_listen: æ˜¯å¦è‡ªåŠ¨æ³¨å†Œäº¤äº’äº‹ä»¶ç›‘å¬ï¼Œé»˜è®¤ä¸ºFalse
        """
        if self.data_bundle.kline_data is None:
            raise ValueError("ç¼ºå°‘Kçº¿æ•°æ®")

        config = ChartConfig()
        volume = ChartFactory.create_chart("volume", config)
        fig = volume.render(self.data_bundle.kline_data)
        
        # åªæœ‰auto_listenä¸ºTrueæ—¶æ‰æ³¨å†Œäº‹ä»¶ç›‘å¬
        if auto_listen:
            self._get_interaction_service().subscribe(
                lambda x_range: fig.update_xaxes(range=x_range))
            
        return fig

    def create_capital_flow_chart(self, config: Optional[dict] = None) -> go.Figure:
        """åˆ›å»ºèµ„é‡‘æµå›¾è¡¨(é€šè¿‡å·¥å‚æ¨¡å¼)"""
        if self.data_bundle.capital_flow is None:
            raise ValueError("ç¼ºå°‘èµ„é‡‘æµæ•°æ®")

        # é€šè¿‡å·¥å‚åˆ›å»ºå›¾è¡¨å®ä¾‹
        flow_config = ChartConfig()
        capital_chart = ChartFactory.create_chart("capital_flow", flow_config)

        # åº”ç”¨è‡ªå®šä¹‰é…ç½® - ç›´æ¥ä½¿ç”¨é…ç½®å€¼
        if config:
            capital_chart.main_color = config.get("main_color", "#4E79A7")
            capital_chart.north_color = config.get("north_color", "#59A14F")
        else:
            # ä½¿ç”¨é»˜è®¤å€¼
            capital_chart.main_color = "#4E79A7"
            capital_chart.north_color = "#59A14F"

        return capital_chart.render(self.data_bundle.capital_flow)


    def create_traces(self, config, data_source, is_secondary=False):
        """åŠ¨æ€ç”Ÿæˆtraceçš„å·¥å‚å‡½æ•°"""
        trace_type_map = {
            'Kçº¿å›¾': go.Candlestick,
            'æŠ˜çº¿å›¾': go.Scatter,
            'æŸ±çŠ¶å›¾': go.Bar
        }
        
        traces = []
        # graph_type = trace_type_map[config.get('type', 'æŠ˜çº¿å›¾')]
        style = config.get('style', {})
        
        count = 0
        if config.get('type', 'æŠ˜çº¿å›¾') == 'Kçº¿å›¾':
            count = count + 1
            # self.logger.debug(f"æ­£åœ¨ä½œå›¾trace_{count},graph_type = {graph_type}, fields = {config['fields']}")
            trace = self.drawCandlestick(data_source)
            traces.append((trace, is_secondary))
            self.logger.debug(f"my_trace is {trace}, my is_sec is {is_secondary}")
        else:
            for field in config['fields']: # 
                count = count + 1
                # self.logger.debug(f"æ­£åœ¨ä½œå›¾trace_{count},graph_type = {graph_type}, fields = {config['fields']}")
                
                trace = go.Bar(
                    x=data_source.index,
                    y=data_source[field],
                    name=f"{config['type']}-{field}",
                    marker=dict(
                        opacity=style.get('opacity', 0.6),
                        color=style.get('color', '#ff7f0e')
                    )
                )
                traces.append((trace, is_secondary))
                self.logger.debug(f"my_trace is {trace}, my is_sec is {is_secondary}")
        return traces


    def create_combined_chart(
        self,
        config: dict,
        primary_cols: Optional[List[str]] = None,
        secondary_cols: Optional[List[str]] = None
    ) -> go.Figure:
        """
        åˆ›å»ºæ”¯æŒå•/åŒYè½´çš„ç»„åˆå›¾è¡¨

        Parameters:
        -----------
        config : dict
            å›¾è¡¨é…ç½®å­—å…¸ï¼Œç»“æ„ç¤ºä¾‹ï¼š
            {
                "main_chart": {
                    "type": "Kçº¿å›¾",       # ä¸»å›¾ç±»å‹æ ‡è¯†
                    "fields": ["close"],  # æ˜¾ç¤ºå­—æ®µ
                    "data_source": "kline_data",  # æ•°æ®æºæ ‡è¯†
                    "style": {            # æ ·å¼é…ç½®ï¼ˆå‚è€ƒç½‘é¡µ4ï¼‰
                        "line_width": 1.5,
                        "color": "#2c7be5"
                    }
                },
                "sub_chart": {
                    "show": True,         # æ˜¯å¦æ˜¾ç¤ºå‰¯å›¾
                    "type": "æˆäº¤é‡",      # å‰¯å›¾ç±»å‹æ ‡è¯†  
                    "fields": ["volume"], # æ˜¾ç¤ºå­—æ®µ
                    "data_source": "trade_records", # æ•°æ®æºæ ‡è¯†
                    "yaxis_name": "æˆäº¤é‡", # Yè½´æ ‡ç­¾
                    "style": {
                        "type": "bar",    # å›¾å½¢ç±»å‹ï¼ˆbar/lineï¼‰
                        "opacity": 0.6
                    }
                }
            }

        sub_chart.style.type = 'bar'  --- æŸ±çŠ¶å›¾            
        'scatter'  --- æŠ˜çº¿å›¾
        
        Returns:
        --------
        go.Figure
            é…ç½®å¥½çš„Plotlyå›¾è¡¨å¯¹è±¡

        Examples:
        ---------
        >>> # å•Yè½´è°ƒç”¨
        >>> fig = create_combined_chart(df, ['close', 'MA20'])

        >>> # åŒYè½´è°ƒç”¨
        >>> fig = create_combined_chart(df, ['close'], ['volume'], "æˆäº¤é‡")
        """
        from plotly.subplots import make_subplots

        fig = make_subplots(shared_xaxes=True, specs=[[{"secondary_y": config['sub_chart'].get('show', True)}]])
        
        # st.write(self.data_bundle.kline_data.index) # debug
        # åŠ¨æ€å¤„ç†ä¸»å‰¯å›¾é…ç½®
        chart_configs = [
            (config['main_chart'], self.data_bundle.kline_data, False),
            (config['sub_chart'], self.data_bundle.kline_data, True)
            if config['sub_chart'].get('show') else (None, None, None)
        ]
        
        for cfg, data, secondary in chart_configs:
            if cfg and data is not None: # æœ‰å‚æ•°ï¼Œæœ‰æ•°æ®
                for trace, is_secondary in self.create_traces(cfg, data, secondary):
                    fig.add_trace(trace, secondary_y=is_secondary)
                    self.logger.debug(f"å·²æ·»åŠ {trace}")
        
        fig.update_layout(
            hovermode='x unified',
            legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
            xaxis=dict(
                title="æ—¶é—´",
                tickvals=self.data_bundle.kline_data.index[::33],
                ticktext=self.data_bundle.kline_data["date"][::33],
                tickangle=45,
            ),
            yaxis1=dict(
                fixedrange=False, # ä¸å›ºå®šYè½´èŒƒå›´
                
                title="price"), # bug:éœ€è¦è°ƒæ•´
            
            yaxis2=dict(
                fixedrange=False, # ä¸å›ºå®šYè½´èŒƒå›´
                showgrid=config['sub_chart'].get('show', True),
                title=config['sub_chart'].get('yaxis_name', 'Secondary Y'),
                visible=config['sub_chart'].get('show', True)
            ) if config['sub_chart'].get('show') else {}
        )
        
        return fig

    def draw_equity_and_allocation(self, equity_data: Optional[pd.DataFrame] = None) -> None:
        """ç»˜åˆ¶å‡€å€¼ä¸èµ„äº§é…ç½®æ¯”ä¾‹å•è½´å›¾è¡¨

        Args:
            equity_data: å‡€å€¼æ•°æ®DataFrameï¼ŒåŒ…å«timestamp, total_value, positions_valueåˆ—
        """
        
        # æ•°æ®å‡†å¤‡ï¼šä½¿ç”¨ä¼ å…¥æ•°æ®æˆ–é»˜è®¤æ•°æ®æº
        data = equity_data if equity_data is not None else self.data_bundle.trade_records
        
        # æ•°æ®éªŒè¯å’Œé¢„å¤„ç†
        if data is None or data.empty:
            raise ValueError("ç¼ºå°‘å‡€å€¼æ•°æ®")
        
        required_cols = {'timestamp', 'total_value', 'positions_value'}
        if not required_cols.issubset(data.columns):
            raise ValueError(f"å‡€å€¼æ•°æ®ç¼ºå°‘å¿…è¦åˆ—ï¼Œéœ€è¦: {required_cols}")
        
        # è®¡ç®—å‡€å€¼ç™¾åˆ†æ¯”å˜åŒ–ï¼ˆç›¸å¯¹äºåˆå§‹å€¼ï¼‰
        initial_value = data['total_value'].iloc[0]
        data = data.copy()
        data['return_pct'] = ((data['total_value'] - initial_value) / initial_value) * 100
        
        # è®¡ç®—èµ„äº§é…ç½®æ¯”ä¾‹ (æŒä»“å¸‚å€¼ / æ€»èµ„äº§ Ã— 100%)
        data['allocation_pct'] = (data['positions_value'] / data['total_value']) * 100
        
        # åˆ›å»ºå•è½´å›¾è¡¨
        fig = go.Figure()
        
        # å‡€å€¼ç™¾åˆ†æ¯”å˜åŒ–
        fig.add_trace(
            go.Scatter(
                x=data['timestamp'],
                y=data['return_pct'],
                name="å‡€å€¼å˜åŒ– (%)",
                line=dict(color="#1f77b4", width=2),
                hovertemplate="%{x}<br>å‡€å€¼: %{y:.2f}%<extra></extra>"
            )
        )
        
        # èµ„äº§é…ç½®æ¯”ä¾‹
        fig.add_trace(
            go.Scatter(
                x=data['timestamp'],
                y=data['allocation_pct'],
                name="èµ„äº§é…ç½®æ¯”ä¾‹ (%)",
                line=dict(color="#ff7f0e", width=2),
                hovertemplate="%{x}<br>é…ç½®æ¯”ä¾‹: %{y:.2f}%<extra></extra>"
            )
        )
        
        # é…ç½®å›¾è¡¨å¸ƒå±€
        fig.update_layout(
            title="ğŸ“Š å‡€å€¼ä¸èµ„äº§é…ç½®åˆ†æ",
            xaxis_title="æ—¶é—´",
            yaxis_title="ç™¾åˆ†æ¯” (%)",
            hovermode="x unified",
            legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
            height=500
        )
        
        # æ·»åŠ 30%æ¿€è¿›ç­–ç•¥è­¦æˆ’çº¿
        fig.add_hline(y=30, line_dash="dash", line_color="red", 
                     annotation_text="æ¿€è¿›ç­–ç•¥è­¦æˆ’çº¿ (30%)", 
                     annotation_position="bottom right")
        
        # æ·»åŠ é›¶çº¿å‚è€ƒ
        fig.add_hline(y=0, line_dash="dash", line_color="green",
                     annotation_text="ç›ˆäºå¹³è¡¡çº¿")

        # æ˜¾ç¤ºå›¾è¡¨
        st.plotly_chart(fig, use_container_width=True)

    def drawMA(self, data: Optional[DataFrame], periods: List[int]) -> List[go.Scatter]:
        """ç»˜åˆ¶å‡çº¿"""
        traces = []
        if data is not None and "close" in data.columns:
            for period in periods:
                ma = data["close"].rolling(window=period).mean()
                traces.append(
                    go.Scatter(
                        x=data.index,
                        y=ma,
                        name=f"MA{period}",
                        line=dict(width=1),
                    )
                )
        return traces

    def drawMACD(self, data: pd.DataFrame, fast=12, slow=26, signal=9):
        """ç»˜åˆ¶MACDæŒ‡æ ‡"""
        exp1 = data["close"].ewm(span=fast, adjust=False).mean()
        exp2 = data["close"].ewm(span=slow, adjust=False).mean()
        macd = exp1 - exp2
        signal_line = macd.ewm(span=signal, adjust=False).mean()
        histogram = macd - signal_line

        fig = go.Figure()
        fig.add_trace(
            go.Scatter(
                x=data.index,
                y=macd,
                name="MACD",
                line=dict(color="blue", width=self.default_line_width),
            )
        )
        fig.add_trace(
            go.Scatter(
                x=data.index,
                y=signal_line,
                name="Signal",
                line=dict(color="orange", width=self.default_line_width),
            )
        )
        fig.add_trace(
            go.Bar(
                x=data.index,
                y=histogram,
                name="Histogram",
                marker_color=np.where(histogram >= 0, "green", "red"),
            )
        )
        fig.update_layout(
            title="MACD", xaxis_title="æ—¶é—´", yaxis_title="MACD", template="plotly_dark"
        )
        st.plotly_chart(fig)

    def drawBollingerBands(self, data, window=20, num_std=2):
        """ç»˜åˆ¶å¸ƒæ—å¸¦"""
        fig = go.Figure()
        rolling_mean = data["close"].rolling(window=window).mean()
        rolling_std = data["close"].rolling(window=window).std()
        upper_band = rolling_mean + (rolling_std * num_std)
        lower_band = rolling_mean - (rolling_std * num_std)

        fig.add_trace(
            go.Scatter(
                x=data.index,
                y=data["close"],
                name="ä»·æ ¼",
                line=dict(color="white", width=self.default_line_width),
            )
        )
        fig.add_trace(
            go.Scatter(
                x=data.index,
                y=upper_band,
                name="ä¸Šè½¨",
                line=dict(color="red", width=self.default_line_width),
            )
        )
        fig.add_trace(
            go.Scatter(
                x=data.index,
                y=rolling_mean,
                name="ä¸­è½¨",
                line=dict(color="blue", width=self.default_line_width),
            )
        )
        fig.add_trace(
            go.Scatter(
                x=data.index,
                y=lower_band,
                name="ä¸‹è½¨",
                line=dict(color="green", width=self.default_line_width),
            )
        )
        fig.update_layout(
            title="å¸ƒæ—å¸¦",
            xaxis_title="æ—¶é—´",
            yaxis_title="ä»·æ ¼",
            template="plotly_dark",
        )
        st.plotly_chart(fig)

    def drawVolume(self, data):
        """ç»˜åˆ¶æˆäº¤é‡å›¾"""
        fig = go.Figure()
        colors = np.where(data["close"] >= data["open"], "green", "red")
        fig.add_trace(
            go.Bar(
                x=data.index,
                y=data["volume"],
                name="æˆäº¤é‡",
                marker_color=colors,
            )
        )
        fig.update_layout(
            title="æˆäº¤é‡",
            xaxis_title="æ—¶é—´",
            yaxis_title="æˆäº¤é‡",
            template="plotly_dark",
        )
        st.plotly_chart(fig)

    def drawCandlestick(self, data):
        """ç»˜åˆ¶Kçº¿å›¾"""
        # åˆå§‹åŒ–ä¸»é¢˜
        current_theme = self._select_theme()

        
        trace = go.Candlestick(
            x=data['date'].index,
            open=data["open"],
            high=data["high"],
            low=data["low"],
            close=data["close"],
            name="Kçº¿",
        )

        return trace

    def _select_theme(self):
        """ä¸»é¢˜é€‰æ‹©ç»„ä»¶"""

        theme_manager = ThemeManager()
        return st.selectbox(
            "ä¸»é¢˜æ¨¡å¼", options=list(theme_manager.themes.keys()), index=0
        )

    def render_ma(self):
        """å‡çº¿ç»„ä»¶"""
        # åˆå§‹åŒ–ä¼šè¯çŠ¶æ€
        if "show_ma" not in st.session_state:
            st.session_state.show_ma = True
        if "ma_periods" not in st.session_state:
            st.session_state.ma_periods = [5, 10, 20]

        # å›è°ƒå‡½æ•°é¿å…ä¸å¿…è¦çš„ rerun  # bug:æœªè§£å†³rerun
        def update_ma_state():
            st.session_state.show_ma = st.session_state["show_ma_checkbox"]
            st.session_state.ma_periods = st.session_state["ma_periods_select"]

        # å‡çº¿ç»„ä»¶
        st.checkbox(
            "æ˜¾ç¤ºå‡çº¿",
            value=st.session_state.show_ma,
            key="show_ma_checkbox",
            on_change=update_ma_state,
        )

        st.multiselect(
            "å‡çº¿å‘¨æœŸ",
            options=[5, 10, 20, 30, 60],
            default=st.session_state.ma_periods,
            key="ma_periods_select",
            on_change=update_ma_state,
        )

        ma_traces = []
        if st.session_state.show_ma:
            ma_traces = self.drawMA(self.data_bundle.kline_data, st.session_state.ma_periods)

        if not ma_traces and st.session_state.show_ma:
            st.warning("è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªå‡çº¿å‘¨æœŸ")
        return ma_traces


    def drawRSI(self, data, window=14):
        """ç»˜åˆ¶ç›¸å¯¹å¼ºå¼±æŒ‡æ•°(RSI)"""
        fig = go.Figure()
        delta = data["close"].diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))
        fig.add_trace(
            go.Scatter(
                x=data.index,
                y=rsi,
                name="RSI",
                line=dict(color="blue", width=self.default_line_width),
            )
        )
        fig.add_hline(y=30, line_dash="dash", line_color="red")
        fig.add_hline(y=70, line_dash="dash", line_color="red")
        fig.update_layout(
            title="ç›¸å¯¹å¼ºå¼±æŒ‡æ•°(RSI)",
            xaxis_title="æ—¶é—´",
            yaxis_title="RSI",
            template="plotly_dark",
        )
        st.plotly_chart(fig)

    def drawallRSI(data, window, color, line_width):
        """ç»˜åˆ¶æ‰€æœ‰RSI"""
        fig_rsi = go.Figure()
        fig_rsi.add_trace(
            go.Scatter(
                x=data.index,
                y=data[f"{window}RSI"],
                yaxis="y1",
                mode="lines",
                line=dict(color=color, width=line_width),
                name=f"{window}RSI",
                hovertext=data["time"],
                showlegend=True,
            )
        )
        fig_rsi.add_hline(
            y=30,
            line_dash="dash",
            line_color="white",
            annotation_text="y=30",
            annotation_position="top left",
        )
        fig_rsi.add_hline(
            y=70,
            line_dash="dash",
            line_color="white",
            annotation_text="y=70",
            annotation_position="top left",
        )
        fig_rsi.update_layout(
            title=f"{window}RSI",
            xaxis=dict(
                gridcolor="white",
                title="æ—¶é—´",
                tickvals=data.index[::1000],
                ticktext=data["time"][::1000],
            ),
            yaxis=dict(
                gridcolor="white",
                title=f"{window}RSI",
                titlefont=dict(color="white"),
                tickfont=dict(color="white"),
                tickvals=[30, 70],
                ticktext=["30", "70"],
            ),
            template="plotly",
            legend=dict(x=0.1, y=1.1),
            hovermode="x unified",
        )
        st.plotly_chart(fig_rsi)

    def drawRSI(data, feature1, line1_col, RSI, line2_col, line_width):
        """ç»˜åˆ¶RSIç›¸å…³å›¾è¡¨"""
        fig4 = go.Figure()
        fig4.add_trace(
            go.Scatter(
                x=data[(data["12RSI"] > 70) | (data["12RSI"] < 30)].index,
                y=data[(data["12RSI"] > 70) | (data["12RSI"] < 30)][feature1],
                yaxis="y1",
                mode="markers",
                marker=dict(color="white", size=line_width),
                name=feature1,
            )
        )
        fig4.add_trace(
            go.Scatter(
                x=data[(data["12RSI"] < 70) & (data["12RSI"] > 30)].index,
                y=data[(data["12RSI"] < 70) & (data["12RSI"] > 30)][feature1],
                yaxis="y1",
                mode="markers",
                marker=dict(color=line1_col, size=line_width),
                name=feature1,
            )
        )
        fig4.add_trace(
            go.Scatter(
                x=data[(data["12RSI"] > 70) | (data["12RSI"] < 30)].index,
                y=data[(data["12RSI"] > 70) | (data["12RSI"] < 30)]["RSI"],
                yaxis="y2",
                mode="markers",
                marker=dict(color="white", size=line_width),
                name="12RSI (Extremes)",
            )
        )
        fig4.add_trace(
            go.Scatter(
                x=data[(data["12RSI"] < 70) & (data["12RSI"] > 30)].index,
                y=data[(data["12RSI"] < 70) & (data["12RSI"] > 30)]["RSI"],
                yaxis="y2",
                mode="markers",
                marker=dict(color=line2_col, size=line_width),
                name="12RSI (Moderate)",
            )
        )
        fig4.update_layout(
            title="xxx",
            xaxis=dict(
                title="æ—¶é—´",
                tickvals=data.index[::1000],
                ticktext=data["time"][::1000],
                tickangle=45,
            ),
            yaxis=dict(
                title=f"feature1",
                titlefont=dict(color="blue"),
                tickfont=dict(color="blue"),
            ),
            yaxis2=dict(
                title=f"RSI",
                titlefont=dict(color="orange"),
                tickfont=dict(color="orange"),
                overlaying="y",
                side="right",
            ),
            template="plotly",
            legend=dict(x=0.5, y=1.1),
            hovermode="x unified",
        )
        st.title("è‚¡ç¥¨å›¾åƒ")
        st.plotly_chart(fig4)

    def create_fund_flow_chart(self, fund_flow_data: pd.DataFrame) -> go.Figure:
        """åˆ›å»ºèµ„é‡‘æµå‘å›¾è¡¨"""
        fig = px.line(
            fund_flow_data,
            x="date",
            y=[
                "main_net_inflow_amt",
                "super_large_net_inflow_amt",
                "large_net_inflow_amt",
                "mid_net_inflow_amt",
                "retail_net_inflow_amt",
            ],
            labels={"value": "èµ„é‡‘æµå‘ (äº¿)", "date": "æ—¥æœŸ", "variable": "èµ„é‡‘ç±»å‹"},
            title="å¤§ç›˜èµ„é‡‘æµå‘åˆ†æ",
        )
        fig.update_layout(
            legend_title_text="èµ„é‡‘ç±»å‹",
            xaxis_title="æ—¥æœŸ",
            yaxis_title="èµ„é‡‘æµå‘ (äº¿)",
        )
        return fig

    def draw_drawdown_analysis(self, equity_data: pd.DataFrame) -> None:
        """ç»˜åˆ¶å›æ’¤åˆ†æå›¾è¡¨

        Args:
            equity_data: å‡€å€¼æ•°æ®DataFrameï¼ŒåŒ…å«timestampå’Œtotal_valueåˆ—
        """
        if equity_data is None or equity_data.empty:
            st.warning("æ— å‡€å€¼æ•°æ®å¯ç”¨äºå›æ’¤åˆ†æ")
            return

        # è®¡ç®—å›æ’¤
        equity_data = equity_data.copy()
        equity_data['peak'] = equity_data['total_value'].cummax()
        equity_data['drawdown'] = (equity_data['total_value'] - equity_data['peak']) / equity_data['peak'] * 100

        # åˆ›å»ºå›¾è¡¨
        fig = go.Figure()

        # æ·»åŠ å›æ’¤æ›²çº¿
        fig.add_trace(
            go.Scatter(
                x=equity_data['timestamp'],
                y=equity_data['drawdown'],
                name="å›æ’¤ (%)",
                line=dict(color="red", width=2),
                fill='tozeroy',
                fillcolor='rgba(255,0,0,0.2)'
            )
        )

        # é…ç½®å›¾è¡¨
        fig.update_layout(
            title="å›æ’¤åˆ†æ",
            xaxis_title="æ—¶é—´",
            yaxis_title="å›æ’¤ (%)",
            template="plotly_white",
            height=400
        )

        st.plotly_chart(fig, use_container_width=True)

    def draw_returns_distribution(self, equity_data: pd.DataFrame) -> None:
        """ç»˜åˆ¶æ”¶ç›Šåˆ†å¸ƒå›¾è¡¨

        Args:
            equity_data: å‡€å€¼æ•°æ®DataFrameï¼ŒåŒ…å«timestampå’Œtotal_valueåˆ—
        """
        if equity_data is None or equity_data.empty:
            st.warning("æ— å‡€å€¼æ•°æ®å¯ç”¨äºæ”¶ç›Šåˆ†å¸ƒåˆ†æ")
            return

        # è®¡ç®—æ—¥æ”¶ç›Šç‡
        equity_data = equity_data.copy()
        equity_data['daily_return'] = equity_data['total_value'].pct_change() * 100

        # åˆ›å»ºç›´æ–¹å›¾
        fig = px.histogram(
            equity_data,
            x='daily_return',
            title="æ—¥æ”¶ç›Šç‡åˆ†å¸ƒ",
            nbins=50,
            labels={'daily_return': 'æ—¥æ”¶ç›Šç‡ (%)'}
        )

        # æ·»åŠ ç»Ÿè®¡ä¿¡æ¯
        mean_return = equity_data['daily_return'].mean()
        std_return = equity_data['daily_return'].std()

        fig.add_vline(x=mean_return, line_dash="dash", line_color="red",
                     annotation_text=f"å‡å€¼: {mean_return:.2f}%")
        fig.add_vline(x=mean_return + std_return, line_dash="dash", line_color="orange",
                     annotation_text=f"+1Ïƒ: {mean_return + std_return:.2f}%")
        fig.add_vline(x=mean_return - std_return, line_dash="dash", line_color="orange",
                     annotation_text=f"-1Ïƒ: {mean_return - std_return:.2f}%")

        fig.update_layout(height=400)
        st.plotly_chart(fig, use_container_width=True)

    def draw_trading_signals(self, price_data: pd.DataFrame, signals_data: pd.DataFrame) -> None:
        """ç»˜åˆ¶äº¤æ˜“ä¿¡å·å›¾è¡¨

        Args:
            price_data: ä»·æ ¼æ•°æ®DataFrame
            signals_data: ä¿¡å·æ•°æ®DataFrame
        """
        if price_data is None or price_data.empty:
            st.warning("æ— ä»·æ ¼æ•°æ®å¯ç”¨äºä¿¡å·åˆ†æ")
            return

        # åˆ›å»ºKçº¿å›¾
        fig = go.Figure()

        # æ·»åŠ Kçº¿
        fig.add_trace(
            go.Candlestick(
                x=price_data.index,
                open=price_data['open'],
                high=price_data['high'],
                low=price_data['low'],
                close=price_data['close'],
                name="Kçº¿"
            )
        )

        # å¦‚æœæœ‰ä¿¡å·æ•°æ®ï¼Œæ·»åŠ äº¤æ˜“ä¿¡å·æ ‡è®°
        if signals_data is not None and not signals_data.empty:
            buy_signals = signals_data[signals_data['signal'] == 'BUY']
            sell_signals = signals_data[signals_data['signal'] == 'SELL']

            if not buy_signals.empty:
                fig.add_trace(
                    go.Scatter(
                        x=buy_signals.index,
                        y=buy_signals['price'],
                        mode='markers',
                        marker=dict(symbol='triangle-up', size=10, color='green'),
                        name='ä¹°å…¥ä¿¡å·'
                    )
                )

            if not sell_signals.empty:
                fig.add_trace(
                    go.Scatter(
                        x=sell_signals.index,
                        y=sell_signals['price'],
                        mode='markers',
                        marker=dict(symbol='triangle-down', size=10, color='red'),
                        name='å–å‡ºä¿¡å·'
                    )
                )

        fig.update_layout(
            title="äº¤æ˜“ä¿¡å·åˆ†æ",
            xaxis_title="æ—¶é—´",
            yaxis_title="ä»·æ ¼",
            template="plotly_white",
            height=500
        )

        st.plotly_chart(fig, use_container_width=True)
